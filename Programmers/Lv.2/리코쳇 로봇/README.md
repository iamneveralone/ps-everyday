## 문제 출처

<a href="https://school.programmers.co.kr/learn/courses/30/lessons/169199" rel="nofollow">리코쳇 로봇</a>

## 🔍 풀이

BFS를 사용하는 문제이다.

목표 위치까지의 최소 이동 횟수를 구해야하는 문제이기 때문에 DFS보다는 최소를 보장할 수 있는 BFS를 사용하는 것이 더 좋은 접근이다.

다음 코드가 이 문제에서 가장 중요한 코드이다.

```
while(nx >= 0 && ny >= 0 && nx < n && ny < m && board[nx][ny] != 'D'){
      nx += dir[k][0];
      ny += dir[k][1];
}
```

위 코드는 맨 끝이나 장애물을 만날 때까지 같은 방향으로 쭉 미끄러져 이동하는 부분을 구현한 코드이다.

그리고 맨 끝이나 장애물을 만났을 때 그 바로 직전의 위치에서 방향을 틀어야 하기 때문에, 다음과 같이 nx와 ny를 직전 위치로 한 칸 이동해야 한다.

```
nx -= dir[k][0];
ny -= dir[k][1];
```

## ✏️ 추가 지식

없다.

## 😊 후기

처음에 문제에서 주어진 예시를 이해하는 데 시간을 오래 썼다.

그리고, 별 생각 없이 DFS로 접근했는데 다음에는 문제에 따라 DFS로 접근할지 BFS로 접근할지 잘 선택을 해야겠다고 생각했다.